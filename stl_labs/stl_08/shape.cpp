//region Task
/* Разработать программу, которая:
 * 1. Реализует иерархию геометрических фигур состоящую из:
 *  1. Класс Shape
 *      1. Содержит информацию о положении центра фигуры (координаты x и y).
 *      2. Содердит метод IsMoreLeft, позволяющий определить расположена ли данная
 *         фигура левее (определяется по положению центра) чем фигура переданная в качестве
 *         аргумента
 *      3. Содердит метод IsUpper, позволяющий определить расположена ли данная фигура выше
 *         (определяется по положению центра) чем фигура переданная в качестве аргумента
 *      4. Определяет чисто виртаульную функцию рисования Draw (каждая фигура в реализации
 *         этой функци должна выводить на стандартный вывод свое название и положение цента)
 *  2. Класс Circle производный от класса Shape
 *      1. Реализует Draw
 *  3. Класс Triangle производный от класса Shape
 *      1. Реализует Draw
 *  4. Класс Square производный от класса Shape
 *      1. Реализует Draw
 *
 * 2. Содержит список list<Shape*>, заполенный указателями на различные фигуры
 * 3. С помощью стандартных алгоритмов и адаптеров выводит (Draw) все фигуры
 * 4. С помощью стандартных алгоритмов и адаптеров сортирует список по положению
 *    центра слева-направо (имется в виду, что в начале списка должны идти фигуры находящиеся левее,
 *    координата x ) и выводит фигуры (Draw)
 * 5. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра
 *    справа-налево и выводит фигуры
 * 6. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра сверху-вниз
 *    и выводит фигуры
 * 7. С помощью стандартных алгоритмов и адаптеров сортирует список по положению центра снизу-вверх
 *    и выводит фигуры
 * */
//endregion Task

#include <iostream>


struct Point
{
    int x;
    int y;
};

class Shape
{
public:

    Shape (){ center = defaultPoint; };

    Shape(Point _center) {
        center = _center;
    };

    void PrintShape()
    {
        std::cout << center.x << " " << center.y << std::endl;
    }

    bool IsMoreLeft(Shape& sh2)
    {
        return center.x < sh2.center.x;
    }

    bool IsUpper(Shape& sh2)
    {
        return center.y < sh2.center.y;
    }

private:
    Point center;
    Point defaultPoint = {0, 0};
};

int main()
{
    Shape shape;
    Shape shape2 = {Point {2, 2}};

    shape.PrintShape();

    if (shape.IsMoreLeft(shape2))
        std::cout << "More left\n";
    else
        std::cout << "No more left\n";

    if (shape.IsUpper(shape2))
        std::cout << "Upper\n";
    else
        std::cout << "Not upper\n";


    return 0;
}

